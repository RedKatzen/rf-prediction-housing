# -*- coding: utf-8 -*-
"""Trabalho 2 de CD - Random Forest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xqSrJCFrB-VMFnfDbD3UMjHNFUzySY62
"""

import matplotlib.pyplot as plt
import pandas as pd
import codecs
import seaborn as sns
import statsmodels.api as sm
from sklearn.metrics import r2_score
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split

with codecs.open('/content/drive/MyDrive/Classroom/Ciência de dados/2º Trabalho/Housing.csv', 'r', encoding='ISO-8859-1') as f:
    data = pd.read_csv(f)
# OU
# data = pd.read_csv('Housing.csv')

data.shape

data.head(5)

"""# Tratando o dataset - limpeza de colunas desnecessárias"""

# Removendo colunas desnessárias
colunas_remocao = ['id', 'date', 'waterfront', 'view', 'grade', 'sqft_above', 'sqft_basement', 'lat', 'yr_renovated', 'long', 'sqft_living15', 'sqft_lot15']
ds = data.drop(columns=colunas_remocao)

# Salvando o tratamento em um novo arquivo
ds.to_csv('housing_tratado.csv', index=False)

"""# Fazendo primeiras análises com dataset tratado"""

data_rf = pd.read_csv('housing_tratado.csv')

data_rf.shape

data_rf.head(1)

nulos = data_rf.isnull().sum()
nulos

data_dispersao = data_rf[(data_rf['price'] < 2000000) & (data_rf['sqft_lot'] < 10000)]
data_dispersao.shape

plt.figure(figsize=(10, 6))
sns.scatterplot(x='sqft_lot', y='price', data=data_dispersao.sample(50))
plt.title('Relação de área de terreno e preço de casas')
plt.xlabel('Área do terreno (em pés²)')
plt.ylabel('Valor da casa (US$)', )
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(x='sqft_living', y='price', data=data_dispersao.sample(50))
plt.title('Relação de área de construção e preço de casas')
plt.xlabel('Área da casa (em pés²)')
plt.ylabel('Valor da casa (US$)', )
plt.show()

preco_medio_por_bairro = data_dispersao.sample(50).groupby('zipcode')['price'].mean().sort_values(ascending=False)

media_total = preco_medio_por_bairro.mean()
print(f'Preço médio total: {media_total:,.2f}\n')

plt.figure(figsize=(10, 6))
sns.barplot(x=preco_medio_por_bairro.index, y=preco_medio_por_bairro.values, palette='viridis')
plt.title('Preço médio das casas por bairro')
plt.xlabel('Região')
plt.ylabel('Preço médio (US$)')
plt.xticks(rotation=45)
plt.show()

"""**Visualizar o peso das variáveis/dos coeficientes na predição da dependente**"""

importances = rf_model.feature_importances_ # valores de importancia
variaveis_rf = X_rf.columns # as variáveis

plt.figure(figsize=(10, 6))
plt.bar(variaveis_rf, importances, color='green')
plt.title('Peso de cada variável para o modelo')
plt.xlabel('Variáveis')
plt.ylabel('Importância')
plt.xticks(rotation=45)
plt.show()

"""# Modelo 01 e 02 - sem delimitação

**Modelo 01**
"""

data_rf.shape

X_rf = data_rf.drop('price', axis=1)
y_rf = data_rf['price']

X_train_rf, X_test_rf, y_train_rf, y_test_rf = train_test_split(X_rf, y_rf, test_size=0.2, random_state=42)

rf_model = RandomForestRegressor(n_estimators=500, random_state=42)
rf_model.fit(X_rf, y_rf)

y_predic = rf_model.predict(X_test_rf)

r2_score_1 = r2_score(y_test_rf, y_predic)
print(f'R² score: {r2_score_1}')

residuos = y_test_rf - y_predic

# buscar residuos
plt.scatter(y_test_rf, residuos)
plt.axhline(y=0, color='r', linestyle='--')
plt.legend(['Resíduos', 'Linha de zero'])
plt.title('Resíduos do modelo')
plt.xlabel('Valores reais')
plt.ylabel('Resíduos')
plt.show()

"""**Buscar resíduos da predição** - identificar quão preciso é o modelo e áreas onde erra

Concentração em ZERO
- Quando a maioria dos resíduos está próxima de zero, isso significa que as previsões do modelo estão, em geral, próximas dos valores reais.

Acima de ZERO
- Se os resíduos estão frequentemente positivos, isso indica que o modelo está subestimando os valores reais.
- Pode ser que o modelo tenha dificuldade de prever valores muito altos

**Modelo 02**
"""

X_rf_2 = data_rf.drop('price', axis=1)
y_rf_2 = data_rf['price']

X_train_rf_2, X_test_rf_2, y_train_rf_2, y_test_rf_2 = train_test_split(X_rf_2, y_rf_2, test_size=0.2, random_state=42)

rf_model_2 = RandomForestRegressor(n_estimators=200, random_state=42)
rf_model_2.fit(X_rf_2, y_rf_2)

y_predic_2 = rf_model_2.predict(X_test_rf)

r2_score_2 = r2_score(y_test_rf_2, y_predic_2)
print(f'R² score: {r2_score_2}')

residuos_2 = y_test_rf_2 - y_predic_2

# buscar residuos
plt.scatter(y_test_rf_2, residuos_2)
plt.axhline(y=0, color='r', linestyle='--')
plt.legend(['Resíduos', 'Linha de zero'])
plt.title('Resíduos do modelo')
plt.xlabel('Valores reais')
plt.ylabel('Resíduos')
plt.show()

"""# Modelo 03 - com delimitação tamanho do lote e da casa"""

data_deli = data_rf[(data_rf['sqft_lot'] < 25000) & (data_rf['sqft_living'] < 2500)]

data_deli.shape

"""**Modelo 3**"""

X_rf_3 = data_deli.drop('price', axis=1)
y_rf_3 = data_deli['price']

X_train_rf_3, X_test_rf_3, y_train_rf_3, y_test_rf_3 = train_test_split(X_rf_3, y_rf_3, test_size=0.2, random_state=42)

rf_model_3 = RandomForestRegressor(n_estimators=500, max_depth=20, random_state=42)
rf_model_3.fit(X_rf, y_rf)

y_predic_3 = rf_model_3.predict(X_test_rf_3)

r2_score_3 = r2_score(y_test_rf_3, y_predic_3)
print(f'R² score: {r2_score_3}')

residuos_3 = y_test_rf_3 - y_predic_3

# buscar residuos
plt.scatter(y_test_rf_3, residuos_3)
plt.axhline(y=0, color='r', linestyle='--')
plt.legend(['Resíduos', 'Linha de zero'])
plt.title('Resíduos do modelo')
plt.xlabel('Valores reais')
plt.ylabel('Resíduos')
plt.show()

"""# Modelo 05 - delimitando máx. do preço

**Modelo 05**
"""

data_deli_3 = data_rf[data_rf['price'] < 1000000]

data_deli_3.shape

X_rf_5 = data_deli_3.drop('price', axis=1)
y_rf_5 = data_deli_3['price']

X_train_rf_5, X_test_rf_5, y_train_rf_5, y_test_rf_5 = train_test_split(X_rf_5, y_rf_5, test_size=0.2)

rf_model_5 = RandomForestRegressor(n_estimators=500, random_state=42)
rf_model_5.fit(X_rf_5, y_rf_5)

y_predic_5 = rf_model_5.predict(X_test_rf_5)

r2_score_5 = r2_score(y_test_rf_5, y_predic_5)
print(f'R² score: {r2_score_5}')

residuos_5 = y_test_rf_5 - y_predic_5

# buscar residuos
plt.scatter(y_test_rf_5, residuos_5)
plt.axhline(y=0, color='r', linestyle='--')
plt.legend(['Resíduos', 'Linha de zero'])
plt.title('Resíduos do modelo')
plt.xlabel('Valores reais')
plt.ylabel('Resíduos')
plt.show()

"""# Comparando o resultado dos modelos"""

modelos = ['rf_model', 'rf_model_2', 'rf_model_3', 'rf_model_5']
r2_scores = [r2_score_1, r2_score_2, r2_score_3, r2_score_5]
cores = ['darkblue', 'darkgreen', 'darkred', 'purple']

plt.bar(modelos, r2_scores, color=cores)
plt.title('Comparação de R² entre Modelos')
plt.ylabel('R² Score')
plt.xlabel('Modelos')
plt.grid(axis='y', linestyle='-', alpha=1)
plt.ylim(0, 1)  # Para normalizar o eixo Y entre 0 e 1
plt.show()

"""# Fazendo a previsão de uma nova casa com primeiro modelo"""

resultados = X_test_rf_5.copy()
resultados['Preço previsto'] = y_predic_5.round(2)
resultados['Preço real'] = y_test_rf_5

resultados.head(5)

nova_casa = [[2, 1, 2600, 5800, 1, 4, 1996, 98058]] # [bedrooms,	bathrooms,	sqft_living,	sqft_lot,	floors,	condition,	yr_built,	zipcode]

preco_previsto_1 = rf_model.predict(nova_casa)
print(f'Preço previso para a casa: {preco_previsto_1[0]:,.2f}\n')

preco_previsto_2 = rf_model_2.predict(nova_casa)
print(f'Preço previso para a casa: {preco_previsto_2[0]:,.2f}\n')

preco_previsto_3 = rf_model_3.predict(nova_casa)
print(f'Preço previso para a casa: {preco_previsto_3[0]:,.2f}\n')

preco_previsto_5 = rf_model_5.predict(nova_casa)
print(f'Preço previso para a casa: {preco_previsto_5[0]:,.2f}\n')